package org.example.analsys.Android;

import org.example.visual.AndroidCallGraphFilter;
import org.example.visual.Visualizer;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.jimple.infoflow.InfoflowConfiguration;
import soot.jimple.infoflow.android.InfoflowAndroidConfiguration;
import soot.jimple.infoflow.android.SetupApplication;
import soot.jimple.toolkits.callgraph.CallGraph;
import soot.jimple.toolkits.callgraph.Edge;

import java.io.File;
import java.util.*;

public class AndroidCallgraph {
    private static String androidJar = "F:\\AndroidSdk\\platforms";
    static String androidDemoPath = System.getProperty("user.dir") + File.separator + "demo" + File.separator + "Android";
    static String apkPath = androidDemoPath + File.separator + "st_demo.apk";
    static String childMethodSignature = "<dev.navids.multicomp1.ClassChild: void childMethod()>";
    static String childBaseMethodSignature = "<dev.navids.multicomp1.ClassChild: void baseMethod()>";
    static String parentMethodSignature = "<dev.navids.multicomp1.ClassParent: void baseMethod()>";
    static String unreachableMethodSignature = "<dev.navids.multicomp1.ClassParent: void unreachableMethod()>";
    //因为是创建的虚拟main函数，所以是这样定义的，实际的app代码中并没有这一段
    static String mainActivityEntryPointSignature = "<dummyMainClass: dev.navids.multicomp1.MainActivity dummyMainMethod_dev_navids_multicomp1_MainActivity(android.content.Intent)>";
    static String mainActivityClassName = "dev.navids.multicomp1.MainActivity";

    static Boolean draw = false;
    //两种算法的差别，SPARK更慢，但是会更精准，但是不排除miss Edge的情况，CHA相比之下会更快，但是相对的会没SPARK精准
    //注意精准并不是说CHA比SPARK包含的信息更少，有时候CHA可能包含了过多的边，比如A继承B，但是main方法即指向A也指向B
    //static InfoflowConfiguration.CallgraphAlgorithm algorithm = InfoflowConfiguration.CallgraphAlgorithm.SPARK;
    //static InfoflowConfiguration.CallgraphAlgorithm algorithm = InfoflowConfiguration.CallgraphAlgorithm.CHA;

    public static void main(String[] args){
        if(System.getenv().containsKey("ANDROID_HOME"))
            androidJar = System.getenv("ANDROID_HOME")+ File.separator+"platforms";
        /*
         *初始化
         */
        // Parse arguments
        InfoflowConfiguration.CallgraphAlgorithm cgAlgorithm = InfoflowConfiguration.CallgraphAlgorithm.SPARK;
        if (args.length > 0 && args[0].equals("CHA"))
            cgAlgorithm = InfoflowConfiguration.CallgraphAlgorithm.CHA;
        boolean drawGraph = true;
        if (args.length > 1 && args[1].equals("draw"))
            drawGraph = true;
        // Setup FlowDroid
        final InfoflowAndroidConfiguration config = AndroidUtil.getFlowDroidConfig(apkPath, androidJar, cgAlgorithm);
        //创建FlowDroid controller
        SetupApplication app = new SetupApplication(config);
        // Create the Callgraph without executing taint analysis
        app.constructCallgraph();
        CallGraph callGraph = Scene.v().getCallGraph();

        /*
         * android类里的方法信息解析
         */
        int classIndex = 0;
        // Print some general information of the generated callgraph. Note that although usually the nodes in callgraph
        // are assumed to be methods, the edges in Soot's callgraph is from Unit to SootMethod.
        AndroidCallGraphFilter androidCallGraphFilter = new AndroidCallGraphFilter(AndroidUtil.getPackageName(apkPath));
        //输出到某个方法有多少出边，有多少入边
        for(SootClass sootClass: androidCallGraphFilter.getValidClasses()){
            System.out.println(String.format("Class %d: %s", ++classIndex, sootClass.getName()));
            for(SootMethod sootMethod : sootClass.getMethods()){
                int incomingEdge = 0;
                for(Iterator<Edge> it = callGraph.edgesInto(sootMethod); it.hasNext(); incomingEdge++,it.next());
                int outgoingEdge = 0;
                for(Iterator<Edge> it = callGraph.edgesOutOf(sootMethod); it.hasNext();outgoingEdge++,it.next());
                System.out.println(String.format("\tMethod %s, #IncomeEdges: %d, #OutgoingEdges: %d", sootMethod.getName(), incomingEdge, outgoingEdge));
            }
        }
        System.out.println("-----------");
        // Retrieve some methods to demonstrate reachability in callgraph
        SootMethod childMethod = Scene.v().getMethod(childMethodSignature);
        SootMethod parentMethod = Scene.v().getMethod(parentMethodSignature);
        SootMethod unreachableMehthod = Scene.v().getMethod(unreachableMethodSignature);
        SootMethod mainActivityEntryMethod = Scene.v().getMethod(mainActivityEntryPointSignature);
        // A better way to find MainActivity's entry method (generated by FlowDroid)
        //Android应用的主要入口类中并不包含main方法。而在FlowDroid中，分析Android应用时需要指定一个main方法，因此需要使用getDummyMainMethod方法为Android应用的主要入口类创建一个虚拟的main方法。
        for(SootMethod sootMethod : app.getDummyMainMethod().getDeclaringClass().getMethods()) {
            if (sootMethod.getReturnType().toString().equals(mainActivityClassName)) {
                System.out.println("MainActivity's entrypoint is " + sootMethod.getName()
                        + " and it's equal to mainActivityEntryMethod: " + sootMethod.equals(mainActivityEntryMethod));
            }
        }
        // Perform BFS from the main entrypoint to see if "unreachableMehthod" is reachable at all or not
        Map<SootMethod, SootMethod> reachableParentMapFromEntryPoint = getAllReachableMethods(app.getDummyMainMethod());
        if(reachableParentMapFromEntryPoint.containsKey(unreachableMehthod))
            System.out.println("unreachableMehthod is reachable, a possible path from the entry point: " + getPossiblePath(reachableParentMapFromEntryPoint, unreachableMehthod));
        else
            System.out.println("unreachableMehthod is not reachable from the entrypoint.");
        // Perform BFS to get all reachable methods from MainActivity's entry point
        // mainActivityEntryMethod也是dummy创建的虚拟main函数签名，所以和前面的app.getDummyMainMethod()没用区别
        Map<SootMethod, SootMethod> reachableParentMapFromMainActivity = getAllReachableMethods(mainActivityEntryMethod);
        // 这里解释一下，因为dummy创建的一个虚拟主函数，这个主函数充当app的入口（因为安卓声明周期的原因，你无法通过正常代码逻辑去理解路径）
        // 这个虚拟的main函数具有生命周期函数，包括onCreate、onStart函数，也是通过在onStart里调用了ClassChild的baseMethod函数
        if(reachableParentMapFromMainActivity.containsKey(childMethod))
            System.out.println("childMethod is reachable from MainActivity, a possible path: " + getPossiblePath(reachableParentMapFromMainActivity, childMethod));
        else
            System.out.println("childMethod is not reachable from MainActivity.");

        if(reachableParentMapFromMainActivity.containsKey(parentMethod))
            System.out.println("parentMethod is reachable from MainActivity, a possible path: " + getPossiblePath(reachableParentMapFromMainActivity, parentMethod));
        else
            System.out.println("parentMethod is not reachable from MainActivity.");


        // Draw a subset of call graph
        if (drawGraph) {
            Visualizer.v().addCallGraph(callGraph,
                    androidCallGraphFilter,
                    new Visualizer.AndroidNodeAttributeConfig(true));
            Visualizer.v().draw();
        }
    }


    /**
     * 使用广度优先算法获得initialMethod的所有可到达的函数
     * @param initialMethod 初始函数
     * @return 可到达函数的一个容器
     */
    public static Map<SootMethod, SootMethod> getAllReachableMethods(SootMethod initialMethod){
        CallGraph callgraph = Scene.v().getCallGraph();
        List<SootMethod> queue = new ArrayList<>();
        queue.add(initialMethod);
        Map<SootMethod, SootMethod> parentMap = new HashMap<>();
        parentMap.put(initialMethod, null);
        for(int i=0; i< queue.size(); i++){
            SootMethod method = queue.get(i);
            for (Iterator<Edge> it = callgraph.edgesOutOf(method); it.hasNext(); ) {
                Edge edge = it.next();
                // 获得这条边的另一个点，也就是当前函数的相邻函数
                SootMethod childMethod = edge.tgt();
                if(parentMap.containsKey(childMethod))
                    continue;
                parentMap.put(childMethod, method);
                queue.add(childMethod);
            }
        }
        return parentMap;
    }

    /**
     *
     * @param reachableParentMap 可达到函数的容器
     * @param it 目标函数
     * @return 返回到达这个函数的路径
     */
    public static String getPossiblePath(Map<SootMethod, SootMethod> reachableParentMap, SootMethod it) {
        String possiblePath = null;
        // 循环进行路径拼接
        while(it != null){
            String itName = it.getDeclaringClass().getShortName()+"."+it.getName();
            if(possiblePath == null)
                possiblePath = itName;
            else
                possiblePath = itName + " -> " + possiblePath;
            it = reachableParentMap.get(it);
        } return possiblePath;
    }

}
